#pragma once

#include <algorithm>
#include <cmath>
#include <cstdarg>
#include <iostream>
#include <map>
#include <numeric>
#include <stdexcept>
#include <sstream>
#include <vector>

// Quotient group classifier program
// Author: Alexander Novotny

// Ordered n-tuple
template <typename xType>
struct tuple {
	// Size of tuple
	const unsigned n;
	// Elements of tuple
	xType* x;

	tuple(unsigned _n) : n(_n) {
		x = new xType[n];
	}

	tuple(const tuple<xType>& other) : tuple(other.n) {
		*this = other;
	}

	tuple<xType> operator+(const tuple<xType>& other) const {
		if(n != other.n) throw std::logic_error("n-tuple size mismatch");

		tuple re(n);
		for(unsigned i = 0; i < n; i++) {
			re.x[i] = x[i] + other.x[i];
		}

		return re;
	}

	tuple<xType> operator*(const xType& other) const {
		tuple re(n);
		for(unsigned i = 0; i < n; i++) {
			re.x[i] = x[i] * other;
		}

		return re;
	}

	tuple<xType>& operator=(const tuple<xType>& other) {
		if(n != other.n) throw std::logic_error("n-tuple size mismatch");

		for(unsigned i = 0; i < n; i++) {
			x[i] = other.x[i];
		}

		return *this;
	}

	bool operator!=(const tuple<xType>& other) const {
		if(n != other.n) throw std::logic_error("n-tuple size mismatch");

		for(unsigned i = 0; i < n; i++) {
			if(x[i] != other.x[i])
				return true;
		}

		return false;
	}

	bool operator==(const tuple<xType>& other) const {
		if(n != other.n) throw std::logic_error("n-tuple size mismatch");

		for(unsigned i = 0; i < n; i++) {
			if(x[i] != other.x[i])
				return false;
		}

		return true;
	}
};

// A group constructed from finite direct sums of Integeres mod n
struct group {
	// Direct products of Integers_n
	std::vector<unsigned> products;
	// Useful place to store this - not actually calculated in this struct
	unsigned order = 1;
	// See findLargestOrderElement()
	unsigned largestOrderElement = 0;

	group(unsigned n) : products(n) {}

	// Calculate direct sum with another group
	group operator*(const group& other) const {
		group re = *this;
		
		re.products.insert(re.products.end(), other.products.begin(), other.products.end());

		return re;
	}

	// Finds the order of the largest order element
	// Stores into largestOrderElement
	void findLargestOrderElement() {
		largestOrderElement = 1;
		for(unsigned i : products) {
			largestOrderElement = std::lcm(i, largestOrderElement);
		}
	}

	// Generate the identity element for this group
	template <typename xType>
	tuple<xType> identity() const {
		tuple<xType> re(products.size());
		for(unsigned i = 0; i < products.size(); i++) {
			re.x[i] = (xType) 0;
		}
		return re;
	}

	// Generate every element for this group, store in elements
	// elements will not be cleared
	template <typename xType>
	void generateElements(std::vector<tuple<xType>>& elements) const {
		tuple<xType> element = identity<xType>();

		unsigned conductor;
		do {
			for(conductor = 0;
				conductor < products.size() && element.x[conductor] == products[conductor] - 1;
				conductor++) {
				element.x[conductor] = 0;
			}
			if(conductor < products.size()) {
				element.x[conductor]++;
			}

			elements.push_back(element);
		} while(conductor != products.size());
	}

	// Mod a tuple by this group, to ensure it stays an element of this group
	template <typename xType>
	tuple<xType> mod(const tuple<xType>& element) const {
		if(products.size() != element.n) throw std::logic_error("n-tuple size mismatch");
		tuple<xType> re(element.n);

		for(unsigned i = 0; i < element.n; i++) {
			re.x[i] = element.x[i] % products[i];
		}

		return re;
	}
};

// A coset
// Simple container of elements and order
template <typename eType>
struct coset {
	std::vector<eType> elements;
	unsigned order;
};

typedef tuple<unsigned> Tuple;
typedef group Group;
typedef coset<Tuple> Coset;

// Output Operators
std::ostream& operator<<(std::ostream& out, const Tuple& e);
std::ostream& operator<<(std::ostream& out, const Coset& e);
std::ostream& operator<<(std::ostream& out, const Group& g);

// Calculates order of coset gh in group G/H
void orderOfCoset(Coset& gh, const Coset& H, const Group& G);

// Prime factorize n, storing the factorization into primes
// Primes maps a prime p -> n, its power
// For example, the prime factorization of 200 is 2 -> 3, 5 -> 2
void primeFactorize(unsigned n, std::map<unsigned,unsigned>& primes);

// Finds the order of the subgroup of G generated by generator
unsigned orderOfGenerator(const Group& G, const Tuple& generator);

// Finds all possible Isomorphic groups of G, according to the Fundamental Theorem of Finitiely Generated Abelian Groups
// Fills groups with possible isomorphic groups from G/<generator>
void findPossibleIsoGroup(std::vector<Group>& groups, const Group& G, const Tuple& generator);

// Calculates orders of elements in G
// orderTracker is the output - will map orders to number of elements
void calcElementOrders(const Group& G,
	                   const Tuple& generator,
	                   std::map<unsigned,unsigned>& orderTracker);

// Generate a string to print statistics about element orders of groups
// stats maps should be obtained from calcElementOrders()
std::string printStats(std::map<unsigned,unsigned>& stats);
